
%{
#include <iostream>
using namespace std;
int yyerror(const char * const s);
int yylex(void);
#include "hw3_output.hpp"

%}
%token	ID
%token	NUM
%token	STRING

%token	VOID
%token	INT
%token	BYTE
%token	B
%token	BOOL


%token	ASSIGN
%token	TRUE
%token	FALSE
%token	RETURN


%token	WHILE
%token	BREAK
%token	CONTINUE
%token	SC
%token	COMMA






%left	OR
%left	AND
%left	RELOP
%left	PLUS
%left	MULTI
%right NOT
%right LPAREN
%right RPAREN
%left	ELSE
%right	IF
%token LBRACE
%token RBRACE
%%

Program:	Funcs {}
		;

Funcs:		/*epsilon*/ {}
		| FuncDecl Funcs {}
		;

FuncDecl:	RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE  {}
		;

RetType:		Type {}
		| VOID  {}
		;

Formals:		/**/{}
		| FormalsList {}
		;

FormalsList:	FormalDecl {}
		| FormalDecl COMMA FormalsList {}
		;

FormalDecl: 	Type ID {}
		;
Statements:	Statement  {}
		| Statements Statement  {}
		;

Statement:	LBRACE Statements RBRACE  {}
		| Type ID SC  {}
		| Type ID ASSIGN Exp SC  {}
		| ID ASSIGN Exp SC  {}
		| Call SC  {}
		| RETURN SC {}
		| RETURN Exp SC {}
		| IF LPAREN Exp RPAREN Statement {}
		| IF LPAREN Exp RPAREN Statement ELSE Statement {}
		| WHILE LPAREN Exp RPAREN Statement {}
		| BREAK SC  {}
		| CONTINUE SC  {}
		;

Call:		ID LPAREN ExpList RPAREN  {}
		| ID LPAREN RPAREN  {}
		;

ExpList:		Exp  {}
		| Exp COMMA ExpList  {}
		;

Type:		INT  {}
		| BYTE  {}
		| BOOL  {}
		;

Exp:		LPAREN Exp RPAREN  {}
		| Exp IF LPAREN Exp RPAREN ELSE Exp {}
		| Exp PLUS Exp {
						// Need type check and convert with map...
						TokenType new_type;
						int new_val;
						if($3.name == "+")
							new_val = $1.value + $3.value;
						else if($3.name == "-")
							new_val = $1.value - $3.value;
						$$ = new Exp(new_type, stoi(new_val), new_val);
		}
		| Exp MULTI Exp  {
						// Need type check and convert with map...
						TokenType new_type;
						int new_val;
						if($3.name == "*")
							new_val = $1.value * $3.value;
						else if($3.name == "/")
							new_val = $1.value / $3.value;
						$$ = new Exp(new_type, stoi(new_val), new_val);
		}
		| ID  {
			$$ = new Exp($1.type, $1.$1.name,0);
		}
		| Call  {}
		| NUM {}
		| NUM B  {}
		| STRING  {
			$$ = new Exp($1.type, $1.$1.name, $1.value);
		}
		| TRUE  {
			$$ = new Exp(TokenType::TOKEN_BOOL, "TRUE",1);
		}
		| FALSE  {
			$$ = new Exp(TokenType::TOKEN_BOOL, "FALSE",0);
		}
		| NOT Exp  {
			if($2.value == 0) $$ = new Exp($2.type, "TRUE",1);
			else $$ = new Exp($2.type, "FALSE",0);
		}
		| Exp AND Exp  {
						if($1.type! = TokenType::TOKEN_BOOL || $3.type != TokenType::TOKEN_BOOL)
		                    errorMismatch(yylineno);
						int new_val = $1.value & $3.value;
						if(new_val == 0) $$ = new Exp($1.type, "FALSE", new_val);
						else $$ = new Exp($1.type, "TRUE", new_val);
		}
		| Exp OR Exp  {
		                if($1.type! = TokenType::TOKEN_BOOL || $3.type != TokenType::TOKEN_BOOL)
		                    errorMismatch(yylineno);
						int new_val = $1.value | $3.value;
						if(new_val == 0) $$ = new Exp($1.type, "FALSE", new_val);
						else $$ = new Exp($1.type, "TRUE", new_val);
		}		
		| Exp RELOP Exp  {}
		| LPAREN Type RPAREN Exp   {}
		;


%%

int yyerror(const char* const s)
{
  extern int yylineno;
  output::errorSyn(yylineno);
  exit(1);
}

int main(){
	return yyparse();
}
