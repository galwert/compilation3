
%{
#include <iostream>
using namespace std;
int yyerror(const char * const s);
int yylex(void);
#include "hw3_output.h"
#include "declarations.h"
extern int yylineno;
#include <climits>
Stacks* semantic_stacks;
%}
%token	ID
%token	NUM
%token	STRING

%token	VOID
%token	INT
%token	BYTE
%token	B
%token	BOOL


%token	ASSIGN
%token	TRUE
%token	FALSE
%token	RETURN


%token	WHILE
%token	BREAK
%token	CONTINUE
%token	SC
%token	COMMA






%left	OR
%left	AND
%left	RELOP
%left	PLUS
%left	MULTI
%right NOT
%right LPAREN
%right RPAREN
%left	ELSE
%right	IF
%token LBRACE
%token RBRACE
%%

Program:	Funcs {semantic_stacks=new Stacks();}
		;

Funcs:		/*epsilon*/ {output::errorMainMissing();}
		| FuncDecl Funcs {if(!semantic_stacks->is_exsists("main")||!semantic_stacks->is_func("main"))
		output::errorMainMissing();}
		;

FuncDecl:	RetType ID LPAREN Formals RPAREN LBRACE
            {
             semantic_stacks->new_func($2->name,$1->type,$4->args);semantic_stacks->new_scope();}
             Statements RBRACE  { semantic_stacks->exit_scope();}
		;


RetType:		Type {$$->type=$1->type;}
		| VOID  {$$->type=$1->type;}
		;

Formals:		/**/{$$=new FormalList();}
		| FormalsList {$$=new FormalList();}
		;
FormalsList:	FormalDecl {$$ = new FormalList(); $$->args.push_back($1->type);}
		| FormalDecl COMMA FormalsList {$3->args.push_back(new pair<TokenType,string>($1->type,$1->name));$$=$3;}
		;

FormalDecl: 	Type ID {$$=new Node($1->type,$2->name,0);}
		;
Statements:	Statement  {}
		| Statements Statement  {}
		;

Statement:	LBRACE {semantic_stacks->new_scope();}Statements RBRACE  {semantic_stacks->exit_scope();}
		| Type ID SC  {if(semantic_stacks->is_exsists($1->name)){output::errorDef(yylineno,$1->name);}
		$$=new Node($1->type,$2->name,0); semantic_stacks->new_entry($2->name,$1->type);}
		| Type ID ASSIGN Exp SC  {if(semantic_stacks->is_exsists($2->name)){output::errorDef(yylineno,$2->name);}
		if(convert_table[$2->type][$4->type]==false)//check which converstions are relevent
        		    { output::errorMismatch(yylineno);}
        		    if($2->type==TokenType::TOKEN_B && $4->value>255)
        		    {output::errorByteTooLarge (yylineno, std::to_string($3->value));}
		            $$=new Node($1->type,$2->name,$4->value);
		             semantic_stacks->new_entry($2->name,$1->type);}
		| ID ASSIGN Exp SC  {
		if(semantic_stacks->is_exsists($1->name)){output::errorUndef(yylineno,$1->name);}
		if(convert_table[$1->type][$3->type]==false)
		    { output::errorMismatch(yylineno);}
		    if($1->type==TokenType::TOKEN_B&&$3->value>255)
		    {output::errorByteTooLarge (yylineno, std::to_string($3->value));}
		    $1->value=$3->value;}
		| Call SC  {}
		| RETURN SC {if(semantic_stacks->get_func_type()!=TokenType::TOKEN_UNDIF)
		output::errorMismatch(yylineno);}
		| RETURN Exp SC {if(semantic_stacks->get_func_type()!=$2->type)
                         		output::errorMismatch(yylineno);}
		| IF LPAREN Exp RPAREN Statement {}
		| IF LPAREN Exp RPAREN Statement ELSE Statement {}
		| WHILE LPAREN Exp RPAREN{semantic_stacks->whilecounter++;semantic_stacks->new_scope();} Statement {semantic_stacks->whilecounter--;semantic_stacks->exit_scope();}
		| BREAK SC  {if(semantic_stacks->whilecounter==0)
                     		{output::errorUnexpectedBreak(yylineno);}}
		| CONTINUE SC  {if(semantic_stacks->whilecounter==0)
		{output::errorUnexpectedContinue(yylineno);}}
		;

Call:		ID LPAREN ExpList RPAREN  {if(!semantic_stacks->is_exsists($1->name)){output::errorUndef(yylineno,$1->name);}
                                       		if(!semantic_stacks->is_exsists($1->name)){output::errorUndefFunc(yylineno,$1->name);}
                                       		vector<TokenType> args=semantic_stacks->get_args($1->name);
                                       		if(args.size()!=$3->vars->size())
                                       		   output::errorPrototypeMismatch(yylineno,$1->name,$3->to_string_vector());
                                       		for(int i=0; i<args.size();i++)
                                       		{
                                       		    if(args.at(i).type!=$3->vars->at(i)->type)
                                                   		    output::errorPrototypeMismatch(yylineno,$1->name,$3->to_string_vector());
                                       		}
                                       		}
		| ID LPAREN RPAREN  {
		if(!semantic_stacks->is_exsists($1->name)){output::errorUndef(yylineno,$1->name);}
        		if(!semantic_stacks->is_exsists($1->name)){output::errorUndefFunc(yylineno,$1->name);}
        		vector<TokenType> args=semantic_stacks->get_args($1->name);
        		if(args.size()!=0)
        		    output::errorPrototypeMismatch(yylineno,$1->name,semantic_stacks->get_args($1->name));
		}
		;

ExpList:		Exp  {ExpList *explist = new ExpList(); explist->vars->push_back($1);$$=explist;}
		| Exp COMMA ExpList  {Exp* exp= new Exp($1->type,$1->name,$1->value);$3->vars->push_back(exp);$$=$3;}
		;

Type:		INT  {$$->type=TokenType::TOKEN_INT;}
		| BYTE  {$$->type=TokenType::TOKEN_B;}
		| BOOL  {$$->type=TokenType::TOKEN_BOOL;}
		;

Exp:		LPAREN Exp RPAREN  {
	$$ = new Exp($2->type, $2->name, $2->value);
}

		| Exp IF LPAREN Exp RPAREN ELSE Exp {
		    	if($3->type != TokenType::TOKEN_BOOL)
            		  output::errorMismatch(yylineno);
            	int new_val = $1->value & $3->value;
            	if($3->value==1)
            		    $$ = new Exp($1->type, $1->name, $1->value);
            		 else
            		    $$ = new Exp($5->type, $5->name, $5->value);
		}
		| Exp PLUS Exp {
						TokenType new_type;
						int new_val;
						if($1->type==TokenType::TOKEN_STRING||$1->type==TokenType::TOKEN_B||$3->type==TokenType::TOKEN_STRING||$3->type==TokenType::TOKEN_B)
							output::errorMismatch(yylineno);
						if($1->type==TokenType::TOKEN_INT||$3->type==TokenType::TOKEN_INT)
							new_type=TokenType::TOKEN_INT;
						else
							new_type=TokenType::TOKEN_B;
						if($2->name == "+")
							new_val = $1->value + $3->value;
						else if($2->name == "-")
							new_val = $1->value - $3->value;
						$$ = new Exp(new_type, std::to_string(new_val), new_val);
		}
		| Exp MULTI Exp  {
						TokenType new_type;
						int new_val;
						if($1->type==TokenType::TOKEN_STRING||$1->type==TokenType::TOKEN_B||$3->type==TokenType::TOKEN_STRING||$3->type==TokenType::TOKEN_B)
							output::errorMismatch(yylineno);
						if($1->type==TokenType::TOKEN_INT||$3->type==TokenType::TOKEN_INT)
							new_type=TokenType::TOKEN_INT;
						else
							new_type=TokenType::TOKEN_B;
						if($2->name == "*")
							new_val = $1->value * $3->value;
						else if($2->name == "/")
							new_val = $1->value / $3->value;
						$$ = new Exp(new_type, std::to_string(new_val), new_val);
		}
		| ID  {
			$$ = new Exp($1->type, $1->name,0);
		}
		| Call  {}
		| NUM {      $$->type = $1->type;
            $$->value = $1->value;}
		| NUM B  {
		$$->type = TokenType::TOKEN_B;
      $$->value = $1->value;
      if ($1->value > INT_MAX) {
        output::errorByteTooLarge (yylineno, std::to_string($1->value));}
        }
		| STRING  {
			$$ = new Exp($1->type, $1->name, $1->value);
		}
		| TRUE  {
			$$ = new Exp(TokenType::TOKEN_BOOL, "TRUE",1);
		}
		| FALSE  {
			$$ = new Exp(TokenType::TOKEN_BOOL, "FALSE",0);
		}
		| NOT Exp  {
			if($2->value == 0) $$ = new Exp($2->type, "TRUE",1);
			else $$ = new Exp($2->type, "FALSE",0);
		}
		| Exp AND Exp  {
						if($1->type != TokenType::TOKEN_BOOL || $3->type != TokenType::TOKEN_BOOL)
		                    output::errorMismatch(yylineno);
						int new_val = $1->value & $3->value;
						if(new_val == 0) $$ = new Exp($1->type, "FALSE", new_val);
						else $$ = new Exp($1->type, "TRUE", new_val);
		}
		| Exp OR Exp  {
		                if($1->type != TokenType::TOKEN_BOOL || $3->type != TokenType::TOKEN_BOOL)
		                    output::errorMismatch(yylineno);
						int new_val = $1->value | $3->value;
						if(new_val == 0) $$ = new Exp($1->type, "FALSE", new_val);
						else $$ = new Exp($1->type, "TRUE", new_val);
		}		
		| Exp RELOP Exp  {
		        if($1->type != TokenType::TOKEN_BOOL || $3->type != TokenType::TOKEN_BOOL)
		                    output::errorMismatch(yylineno);
		        int new_val;
						if($2->name == "==")
							new_val = $1->value == $3->value;
						if($2->name == "!=")
							new_val = $1->value != $3->value;
						if($2->name == "<")
							new_val = $1->value < $3->value;
						if($2->name == ">")
							new_val = $1->value > $3->value;
						if($2->name == "<=")
							new_val = $1->value <= $3->value;
						if($2->name == ">=")
							new_val = $1->value >= $3->value;
						if(new_val == 1) $$ = new Exp($1->type,"TRUE",new_val);
						else $$ = new Exp($1->type,"FALSE",new_val);
						
		}
		| LPAREN Type RPAREN Exp   {
			if(convert_table[$2->type][$4->type] == TokenType::TOKEN_UNDIF)
				output::errorMismatch(yylineno);
			if($2->type == TokenType::TOKEN_BOOL) $$ = new Exp($2->type,$4->name,$4->value);
			if($2->type == TokenType::TOKEN_INT) $$ = new Exp($2->type,$4->name,$4->value);
			if($2->type == TokenType::TOKEN_B){
				if($4->type == TokenType::TOKEN_INT && $4->value > 255) output::errorByteTooLarge(yylineno,std::to_string($4->value));
				$$ = new Exp($2->type,$4->name,$4->value);
			}
		}
		;


%%

int yyerror(const char* const s)
{
  extern int yylineno;
  output::errorSyn(yylineno);
  exit(1);
}

int main(){
	return yyparse();
}
