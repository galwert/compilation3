
%{
#include <iostream>
using namespace std;
int yyerror(const char * const s);
int yylex(void);
#include "hw3_output.hpp"

%}
%token	ID
%token	NUM
%token	STRING

%token	VOID
%token	INT
%token	BYTE
%token	B
%token	BOOL


%token	ASSIGN
%token	TRUE
%token	FALSE
%token	RETURN


%token	WHILE
%token	BREAK
%token	CONTINUE
%token	SC
%token	COMMA






%left	OR
%left	AND
%left	RELOP
%left	PLUS
%left	MULTI
%right NOT
%right LPAREN
%right RPAREN
%left	ELSE
%right	IF
%token LBRACE
%token RBRACE
%%

Program:	Funcs {semantic_stacks=new Stacks();}
		;

Funcs:		/*epsilon*/ {}
		| FuncDecl Funcs {}
		;

FuncDecl:	RetType ID LPAREN Formals RPAREN LBRACE M Statements RBRACE  { end}
		;

RetType:		Type {}
		| VOID  {}
		;

Formals:		/**/{}
		| FormalsList {}
		;

FormalsList:	FormalDecl {}
		| FormalDecl COMMA FormalsList {}
		;

FormalDecl: 	Type ID {}
		;
Statements:	Statement  {}
		| Statements Statement  {}
		;

Statement:	LBRACE Statements RBRACE  {}
		| Type ID SC  {}
		| Type ID ASSIGN Exp SC  {}
		| ID ASSIGN Exp SC  {}
		| Call SC  {}
		| RETURN SC {}
		| RETURN Exp SC {}
		| IF LPAREN Exp RPAREN Statement {}
		| IF LPAREN Exp RPAREN Statement ELSE Statement {}
		| WHILE LPAREN Exp RPAREN Statement {}
		| BREAK SC  {}
		| CONTINUE SC  {}
		;

Call:		ID LPAREN ExpList RPAREN  {}
		| ID LPAREN RPAREN  {}
		;

ExpList:		Exp  {}
		| Exp COMMA ExpList  {}
		;

Type:		INT  {$$.type=TokenType::TOKEN_INT;}
		| BYTE  {$$.type=TokenType::TOKEN_BYTE;}
		| BOOL  {$$.type=TokenType::TOKEN_BOOL;}
		;

Exp:		LPAREN Exp RPAREN  {
	$$ = new Exp($2.type, $2.name, $2.value);
}

		| Exp IF LPAREN Exp RPAREN ELSE Exp {
		    	if($3.type! = TokenType::TOKEN_BOOL)
            		  errorMismatch(yylineno);
            	int new_val = $1.value & $3.value;
            	if($3.value==1)
            		    $$ = new Exp($1.type, $1.name, $1.value);
            		 else
            		    $$ = new Exp($5.type, $5.name, $5.value);
		}
		| Exp PLUS Exp {
						TokenType new_type;
						int new_val;
						if($1.type==TOKEN_STRING||$1.type==TOKEN_BYTE||$3.type==TOKEN_STRING||$3.type==TOKEN_BYTE)
							errorMismatch(yylineno);
						if($1.type==TOKEN_INT||$3.type==TOKEN_INT)
							new_type=TOKEN_INT;
						else
							new_type=TOKEN_BYTE;
						if($2.name == "+")
							new_val = $1.value + $3.value;
						else if($2.name == "-")
							new_val = $1.value - $3.value;
						$$ = new Exp(new_type, new_val, new_val);
		}
		| Exp MULTI Exp  {
						TokenType new_type;
						int new_val;
						if($1.type==TOKEN_STRING||$1.type==TOKEN_BYTE||$3.type==TOKEN_STRING||$3.type==TOKEN_BYTE)
							errorMismatch(yylineno);
						if($1.type==TOKEN_INT||$3.type==TOKEN_INT)
							new_type=TOKEN_INT;
						else
							new_type=TOKEN_BYTE;
						if($2.name == "*")
							new_val = $1.value * $3.value;
						else if($2.name == "/")
							new_val = $1.value / $3.value;
						$$ = new Exp(new_type, new_val, new_val);
		}
		| ID  {
			$$ = new Exp($1.type, $1.name,0);
		}
		| Call  {}
		| NUM {      $$.type = $1.type;
      $$.value = $1.NAME;}
		| NUM B  {
		$$.type = TYPE_BYTE;
      $$.value = $1.name;
      if ($1.INT > INT_MAX) {
        output::errorByteTooLarge (yylineno, $1.value);}
        }
		| STRING  {
			$$ = new Exp($1.type, $1.name, $1.value);
		}
		| TRUE  {
			$$ = new Exp(TokenType::TOKEN_BOOL, "TRUE",1);
		}
		| FALSE  {
			$$ = new Exp(TokenType::TOKEN_BOOL, "FALSE",0);
		}
		| NOT Exp  {
			if($2.value == 0) $$ = new Exp($2.type, "TRUE",1);
			else $$ = new Exp($2.type, "FALSE",0);
		}
		| Exp AND Exp  {
						if($1.type! = TokenType::TOKEN_BOOL || $3.type != TokenType::TOKEN_BOOL)
		                    errorMismatch(yylineno);
						int new_val = $1.value & $3.value;
						if(new_val == 0) $$ = new Exp($1.type, "FALSE", new_val);
						else $$ = new Exp($1.type, "TRUE", new_val);
		}
		| Exp OR Exp  {
		                if($1.type! = TokenType::TOKEN_BOOL || $3.type != TokenType::TOKEN_BOOL)
		                    errorMismatch(yylineno);
						int new_val = $1.value | $3.value;
						if(new_val == 0) $$ = new Exp($1.type, "FALSE", new_val);
						else $$ = new Exp($1.type, "TRUE", new_val);
		}		
		| Exp RELOP Exp  {
		        if($1.type! = TokenType::TOKEN_BOOL || $3.type != TokenType::TOKEN_BOOL)
		                    errorMismatch(yylineno);
		        int new_val;
						if($2.name == "==")
							new_val = $1.val == $3.val;
						if($2.name == "!=")
							new_val = $1.val != $3.val;
						if($2.name == "<")
							new_val = $1.val < $3.val;
						if($2.name == ">")
							new_val = $1.val > $3.val;
						if($2.name == "<=")
							new_val = $1.val <= $3.val;
						if($2.name == ">=")
							new_val = $1.val >= $3.val;
						if(new_val == 1) $$ = new Exp($1.type,"TRUE",new_val);
						else $$ = new Exp($1.type,"FALSE",new_val);
						
		}
		| LPAREN Type RPAREN Exp   {
			if(convert_table[$2.type][$4.type] == TOKEN_UNDIF)
				errorMismatch(yylineno);
			if($2.type == TOKEN_BOOL) $$ = new Exp($2.type,$4.name,$4.VALUE);
			if($2.type == TOKEN_INT) $$ = new Exp($2.type,$4.name,$4.VALUE);
			if($2.type == TOKEN_BYTE){
				if($4.type == TOKEN_INT && $4.val > 255) errorByteTooLarge(yylineno,$4.value);
				$$ = new Exp($2.type,$4.name,$4.VALUE);
			}
		}
		;


%%

int yyerror(const char* const s)
{
  extern int yylineno;
  output::errorSyn(yylineno);
  exit(1);
}

int main(){
	return yyparse();
}
